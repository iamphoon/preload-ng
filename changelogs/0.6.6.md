# 0.6.6

## Overview

- **Critical bug fixes** and memory leaks in the original codebase
- **TODO items** the original developer planned but never implemented

---

## Part 1: Bug Fixes & Memory Leaks

### Summary

| File          | Issue                             | Severity    | Fix                             |
| ------------- | --------------------------------- | ----------- | ------------------------------- |
| `readahead.c` | FD leak in `set_block()`          | ðŸ”´ Critical | Added `close(fd)` on error path |
| `readahead.c` | Integer overflow in comparators   | ðŸ”´ Critical | Safe comparison pattern         |
| `state.c`     | Copy-paste bug (line 228)         | ðŸ”´ Critical | Fixed variable name             |
| `state.c`     | Memory leak in `read_map()`       | ðŸ”´ Critical | Manual struct cleanup           |
| `state.c`     | FD leak in `preload_state_save()` | ðŸ”´ Critical | Moved `close()` inside else     |
| `state.c`     | Suboptimal buffer allocation      | ðŸŸ¡ Minor    | Increased initial size          |
| `proc.c`      | Memory leak in `proc_get_maps()`  | ðŸ”´ Critical | Ownership tracking              |

### Detailed Fixes

#### 1. File Descriptor Leak in `set_block()` (`readahead.c`)

```c
// Before: fd left open on error
if (0 > fstat(fd, &buf))
  return;

// After:
if (0 > fstat(fd, &buf)) {
  close(fd);
  return;
}
```

#### 2. Integer Overflow in Comparison Functions (`readahead.c`)

```c
// Before: undefined behavior with large values
i = a->offset - b->offset;

// After: safe pattern, always returns -1, 0, or 1
i = (a->offset > b->offset) - (a->offset < b->offset);
```

#### 3. Copy-Paste Bug in Markov Chain (`state.c:228`)

```c
// Before: wrong variable assigned
markov->change_timestamp = a->change_timestamp;

// After:
markov->change_timestamp = b->change_timestamp;
```

#### 4. Memory Leak in `read_map()` Error Path (`state.c`)

```c
// Before: preload_map_free() silently fails due to refcount check
err:
  preload_map_free(map);

// After: manual cleanup
err:
  g_free(map->path);
  g_free(map);
```

#### 5. FD Leak in `preload_state_save()` (`state.c`)

```c
// Before: close() called even when fd == -1
close(fd);

// After: close() moved inside else block, added O_TRUNC
```

#### 6. Memory Leak in `proc_get_maps()` (`proc.c`)

Added ownership tracking with `map_is_new` flag to properly free unused maps.

### Impact

- **5 memory leaks** fixed (accumulate over weeks/months of daemon operation)
- **2 file descriptor leaks** fixed (could exhaust system FD limits)
- **2 undefined behaviors** fixed (could cause crashes or incorrect sorting)
- **1 logic bug** fixed (corrupted Markov chain timestamps)

**Estimated memory savings:** 50-200 MB after weeks of operation.

---

## Part 2: New Features (Originally Planned TODO Items)

### Summary

| Task | Files                        | Description                          |
| ---- | ---------------------------- | ------------------------------------ |
| 1    | `readahead.c`                | madvise fallback for readahead       |
| 2    | `readahead.c`                | Documentation: readahead is advisory |
| 3    | `madvise_utils.c/h`          | Page evacuation with MADV_FREE       |
| 4    | `model_utils.c/h`, `state.c` | Deleted file detection               |
| 5    | `time_utils.c/h`             | CLOCK_BOOTTIME for hibernation       |
| 6    | `proc.c/h`                   | Active/Inactive metrics from meminfo |
| 7    | `prophet.c`, `confkeys.h`    | Buffer memory utilization            |

### Task 1: madvise(2) Fallback for readahead(2)

New function `try_readahead_with_fallback()` handles cases where `readahead()` fails (NFS, older kernels):

```c
static int try_readahead_with_fallback(int fd, off_t offset, size_t length)
{
  if (readahead(fd, offset, length) == 0)
    return 0;

  // Fallback: mmap + madvise(MADV_WILLNEED) + munmap
  if (errno == EINVAL || errno == ENOSYS || errno == EOPNOTSUPP) {
    void *addr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, offset);
    if (addr != MAP_FAILED) {
      int ret = madvise(addr, length, MADV_WILLNEED);
      munmap(addr, length);
      return ret;
    }
  }
  return -1;
}
```

**Edge cases:** Files in `/proc/` and `/sys/` cannot use the madvise fallback.

### Task 2: readahead(2) Behavior Documentation

**Conclusion:** `readahead(2)` is **ADVISORY**, not a command. The kernel may ignore requests under memory pressure.

### Task 3: Page Evacuation Utilities

**New files:** `madvise_utils.c`, `madvise_utils.h`

```c
// Evacuate memory-mapped pages
int preload_evacuate_pages(void *addr, size_t length, int lazy);

// Evacuate file pages (safer for file-backed mappings)
int preload_evacuate_file_pages(int fd, off_t offset, off_t length);

// Check MADV_FREE support (kernel 4.5+)
int preload_check_madv_free_support(void);
```

| Feature  | MADV_DONTNEED           | MADV_FREE |
| -------- | ----------------------- | --------- |
| Kernel   | All                     | 4.5+      |
| Behavior | Immediate discard       | Lazy-free |
| Risk     | Data loss on MAP_SHARED | Safer     |

### Task 4: Deleted File Detection

**New files:** `model_utils.c`, `model_utils.h`

Automatically removes stale entries during `preload_state_save()`:

```c
int preload_validate_exe(const char *path, ino_t inode, time_t mtime);
int preload_validate_map(const char *path);
int preload_cleanup_invalid_entries(GHashTable *exes, GHashTable *maps);
```

### Task 5: Hibernate-Aware Time Tracking

**New files:** `time_utils.c`, `time_utils.h`

Uses `CLOCK_BOOTTIME` (Linux 2.6.39+) which continues during suspend/hibernate:

```c
int64_t preload_get_boottime(void);  // Returns seconds since boot
int preload_check_boottime_support(void);
```

Automatic fallback to `CLOCK_MONOTONIC` on older kernels.

### Task 6: Active/Inactive Memory Metrics

Extended `preload_memory_t` structure in `proc.h`:

```c
typedef struct _preload_memory_t {
  int total, free, buffers, cached;

  // New LRU metrics (Linux 2.6.28+)
  int active, inactive;
  int active_anon, inactive_anon;
  int active_file, inactive_file;

  // MemAvailable (Linux 3.14+)
  int available;

  int pagein, pageout;
} preload_memory_t;
```

### Task 7: Buffer Memory Utilization

**Difference between Buffers and Cached:**

| Field   | Contents                                  | Reclaimable            |
| ------- | ----------------------------------------- | ---------------------- |
| Buffers | Filesystem metadata (inodes, directories) | ~75-85%                |
| Cached  | File contents (page cache)                | Depends on dirty pages |

**New configuration option** in `preload.conf`:

```ini
[model]
# Percentage of buffer memory considered reclaimable (default: 50%)
membuffers = 50
```
